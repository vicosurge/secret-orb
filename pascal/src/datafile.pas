{ datafile.pas - Text-based data file I/O for Secret Orb }
unit DataFile;

{$MODE OBJFPC}

interface

uses
  SysUtils, GameData;

function LoadWorld(const FileName: string; var W: TGameWorld): Boolean;
function SaveWorld(const FileName: string; var W: TGameWorld): Boolean;
function FindRoomByID(var W: TGameWorld; ID: Word): Integer;

implementation

function Trim(const S: string): string;
var
  I, J: Integer;
begin
  I := 1;
  J := Length(S);
  while (I <= J) and (S[I] <= ' ') do Inc(I);
  while (J >= I) and (S[J] <= ' ') do Dec(J);
  Result := Copy(S, I, J - I + 1);
end;

function ParseKeyValue(const Line: string; var Key, Value: string): Boolean;
var
  P: Integer;
begin
  P := Pos('=', Line);
  if P > 0 then
  begin
    Key := Trim(Copy(Line, 1, P - 1));
    Value := Trim(Copy(Line, P + 1, Length(Line) - P));
    Result := True;
  end
  else
    Result := False;
end;

function FindRoomByID(var W: TGameWorld; ID: Word): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 1 to MAX_ROOMS do
    if W.Rooms[I].Active and (W.Rooms[I].ID = ID) then
    begin
      Result := I;
      Exit;
    end;
end;

function LoadWorld(const FileName: string; var W: TGameWorld): Boolean;
var
  F: Text;
  Line, Key, Value: string;
  CurrentIdx: Integer;
  InRoom: Boolean;
begin
  Result := False;
  InitWorld(W);

  {$I-}
  Assign(F, FileName);
  Reset(F);
  {$I+}
  if IOResult <> 0 then Exit;

  CurrentIdx := 0;
  InRoom := False;

  while not Eof(F) do
  begin
    ReadLn(F, Line);
    Line := Trim(Line);

    { Skip empty lines and comments }
    if (Length(Line) = 0) or (Line[1] = ';') or (Line[1] = '#') then
      Continue;

    { Check for section headers }
    if (Length(Line) > 2) and (Line[1] = '[') then
    begin
      if Pos('[WORLD]', UpperCase(Line)) = 1 then
      begin
        InRoom := False;
      end
      else if Pos('[ROOM:', UpperCase(Line)) = 1 then
      begin
        InRoom := True;
        Inc(W.RoomCount);
        CurrentIdx := W.RoomCount;
        if CurrentIdx <= MAX_ROOMS then
        begin
          InitRoom(W.Rooms[CurrentIdx]);
          W.Rooms[CurrentIdx].Active := True;
          { Parse room ID from header [ROOM:n] }
          Value := Copy(Line, 7, Pos(']', Line) - 7);
          W.Rooms[CurrentIdx].ID := StrToIntDef(Value, CurrentIdx);
        end;
      end;
      Continue;
    end;

    { Parse key=value pairs }
    if ParseKeyValue(Line, Key, Value) then
    begin
      Key := UpperCase(Key);

      if not InRoom then
      begin
        { World-level properties }
        if Key = 'TITLE' then
          W.Title := Value
        else if Key = 'START' then
          W.CurrentRoom := StrToIntDef(Value, 1);
      end
      else if (CurrentIdx > 0) and (CurrentIdx <= MAX_ROOMS) then
      begin
        { Room properties }
        if Key = 'NAME' then
          W.Rooms[CurrentIdx].Name := Value
        else if Key = 'DESC' then
          W.Rooms[CurrentIdx].Desc := Value
        else if Key = 'NORTH' then
          W.Rooms[CurrentIdx].Exits[dirNorth] := StrToIntDef(Value, 0)
        else if Key = 'SOUTH' then
          W.Rooms[CurrentIdx].Exits[dirSouth] := StrToIntDef(Value, 0)
        else if Key = 'EAST' then
          W.Rooms[CurrentIdx].Exits[dirEast] := StrToIntDef(Value, 0)
        else if Key = 'WEST' then
          W.Rooms[CurrentIdx].Exits[dirWest] := StrToIntDef(Value, 0);
      end;
    end;
  end;

  Close(F);
  Result := W.RoomCount > 0;
end;

function SaveWorld(const FileName: string; var W: TGameWorld): Boolean;
var
  F: Text;
  I: Integer;
begin
  Result := False;

  {$I-}
  Assign(F, FileName);
  Rewrite(F);
  {$I+}
  if IOResult <> 0 then Exit;

  { Write world header }
  WriteLn(F, '; Secret Orb World Data');
  WriteLn(F, '; Generated by Secret Orb Editor');
  WriteLn(F);
  WriteLn(F, '[WORLD]');
  WriteLn(F, 'TITLE=', W.Title);
  WriteLn(F, 'START=', W.CurrentRoom);
  WriteLn(F);

  { Write rooms }
  for I := 1 to MAX_ROOMS do
  begin
    if W.Rooms[I].Active then
    begin
      WriteLn(F, '[ROOM:', W.Rooms[I].ID, ']');
      WriteLn(F, 'NAME=', W.Rooms[I].Name);
      WriteLn(F, 'DESC=', W.Rooms[I].Desc);
      WriteLn(F, 'NORTH=', W.Rooms[I].Exits[dirNorth]);
      WriteLn(F, 'SOUTH=', W.Rooms[I].Exits[dirSouth]);
      WriteLn(F, 'EAST=', W.Rooms[I].Exits[dirEast]);
      WriteLn(F, 'WEST=', W.Rooms[I].Exits[dirWest]);
      WriteLn(F);
    end;
  end;

  Close(F);
  Result := True;
end;

end.
